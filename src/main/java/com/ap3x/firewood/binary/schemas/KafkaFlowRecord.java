/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package com.ap3x.firewood.binary.schemas;
@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class KafkaFlowRecord extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
    public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"KafkaFlowRecord\",\"namespace\":\"br.com.rivendel.bigdata.binary.schemas\",\"fields\":[{\"name\":\"clazz\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"type\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"metadata\",\"type\":{\"type\":\"record\",\"name\":\"KafkaMetadataRecord\",\"fields\":[{\"name\":\"objectURI\",\"type\":{\"type\":\"string\",\"avro.java.string\":\"String\"}},{\"name\":\"filename\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"default\":null},{\"name\":\"version\",\"type\":\"long\"},{\"name\":\"recordId\",\"type\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"default\":null}]}},{\"name\":\"values\",\"type\":{\"type\":\"map\",\"values\":[\"null\",{\"type\":\"string\",\"avro.java.string\":\"String\"}],\"avro.java.string\":\"String\"}},{\"name\":\"hasQualityIssues\",\"type\":\"boolean\",\"default\":false}]}");
    public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
    @Deprecated public java.lang.String clazz;
    @Deprecated public java.lang.String type;
    @Deprecated public KafkaMetadataRecord metadata;
    @Deprecated public java.util.Map<java.lang.String,java.lang.String> values;
    @Deprecated public boolean hasQualityIssues;

    /**
     * Default constructor.  Note that this does not initialize fields
     * to their default values from the schema.  If that is desired then
     * one should use <code>newBuilder()</code>.
     */
    public KafkaFlowRecord() {}

    /**
     * All-args constructor.
     */
    public KafkaFlowRecord(java.lang.String clazz, java.lang.String type, KafkaMetadataRecord metadata, java.util.Map<java.lang.String,java.lang.String> values, java.lang.Boolean hasQualityIssues) {
        this.clazz = clazz;
        this.type = type;
        this.metadata = metadata;
        this.values = values;
        this.hasQualityIssues = hasQualityIssues;
    }

    public org.apache.avro.Schema getSchema() { return SCHEMA$; }
    // Used by DatumWriter.  Applications should not call.
    public java.lang.Object get(int field$) {
        switch (field$) {
            case 0: return clazz;
            case 1: return type;
            case 2: return metadata;
            case 3: return values;
            case 4: return hasQualityIssues;
            default: throw new org.apache.avro.AvroRuntimeException("Bad index");
        }
    }
    // Used by DatumReader.  Applications should not call.
    @SuppressWarnings(value="unchecked")
    public void put(int field$, java.lang.Object value$) {
        switch (field$) {
            case 0: clazz = (java.lang.String)value$; break;
            case 1: type = (java.lang.String)value$; break;
            case 2: metadata = (KafkaMetadataRecord)value$; break;
            case 3: values = (java.util.Map<java.lang.String,java.lang.String>)value$; break;
            case 4: hasQualityIssues = (java.lang.Boolean)value$; break;
            default: throw new org.apache.avro.AvroRuntimeException("Bad index");
        }
    }

    /**
     * Gets the value of the 'clazz' field.
     */
    public java.lang.String getClazz() {
        return clazz;
    }

    /**
     * Sets the value of the 'clazz' field.
     * @param value the value to set.
     */
    public void setClazz(java.lang.String value) {
        this.clazz = value;
    }

    /**
     * Gets the value of the 'type' field.
     */
    public java.lang.String getType() {
        return type;
    }

    /**
     * Sets the value of the 'type' field.
     * @param value the value to set.
     */
    public void setType(java.lang.String value) {
        this.type = value;
    }

    /**
     * Gets the value of the 'metadata' field.
     */
    public KafkaMetadataRecord getMetadata() {
        return metadata;
    }

    /**
     * Sets the value of the 'metadata' field.
     * @param value the value to set.
     */
    public void setMetadata(KafkaMetadataRecord value) {
        this.metadata = value;
    }

    /**
     * Gets the value of the 'values' field.
     */
    public java.util.Map<java.lang.String,java.lang.String> getValues() {
        return values;
    }

    /**
     * Sets the value of the 'values' field.
     * @param value the value to set.
     */
    public void setValues(java.util.Map<java.lang.String,java.lang.String> value) {
        this.values = value;
    }

    /**
     * Gets the value of the 'hasQualityIssues' field.
     */
    public java.lang.Boolean getHasQualityIssues() {
        return hasQualityIssues;
    }

    /**
     * Sets the value of the 'hasQualityIssues' field.
     * @param value the value to set.
     */
    public void setHasQualityIssues(java.lang.Boolean value) {
        this.hasQualityIssues = value;
    }

    /** Creates a new KafkaFlowRecord RecordBuilder */
    public static KafkaFlowRecord.Builder newBuilder() {
        return new KafkaFlowRecord.Builder();
    }

    /** Creates a new KafkaFlowRecord RecordBuilder by copying an existing Builder */
    public static KafkaFlowRecord.Builder newBuilder(KafkaFlowRecord.Builder other) {
        return new KafkaFlowRecord.Builder(other);
    }

    /** Creates a new KafkaFlowRecord RecordBuilder by copying an existing KafkaFlowRecord instance */
    public static KafkaFlowRecord.Builder newBuilder(KafkaFlowRecord other) {
        return new KafkaFlowRecord.Builder(other);
    }

    /**
     * RecordBuilder for KafkaFlowRecord instances.
     */
    public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<KafkaFlowRecord>
            implements org.apache.avro.data.RecordBuilder<KafkaFlowRecord> {

        private java.lang.String clazz;
        private java.lang.String type;
        private KafkaMetadataRecord metadata;
        private java.util.Map<java.lang.String,java.lang.String> values;
        private boolean hasQualityIssues;

        /** Creates a new Builder */
        private Builder() {
            super(KafkaFlowRecord.SCHEMA$);
        }

        /** Creates a Builder by copying an existing Builder */
        private Builder(KafkaFlowRecord.Builder other) {
            super(other);
            if (isValidValue(fields()[0], other.clazz)) {
                this.clazz = data().deepCopy(fields()[0].schema(), other.clazz);
                fieldSetFlags()[0] = true;
            }
            if (isValidValue(fields()[1], other.type)) {
                this.type = data().deepCopy(fields()[1].schema(), other.type);
                fieldSetFlags()[1] = true;
            }
            if (isValidValue(fields()[2], other.metadata)) {
                this.metadata = data().deepCopy(fields()[2].schema(), other.metadata);
                fieldSetFlags()[2] = true;
            }
            if (isValidValue(fields()[3], other.values)) {
                this.values = data().deepCopy(fields()[3].schema(), other.values);
                fieldSetFlags()[3] = true;
            }
            if (isValidValue(fields()[4], other.hasQualityIssues)) {
                this.hasQualityIssues = data().deepCopy(fields()[4].schema(), other.hasQualityIssues);
                fieldSetFlags()[4] = true;
            }
        }

        /** Creates a Builder by copying an existing KafkaFlowRecord instance */
        private Builder(KafkaFlowRecord other) {
            super(KafkaFlowRecord.SCHEMA$);
            if (isValidValue(fields()[0], other.clazz)) {
                this.clazz = data().deepCopy(fields()[0].schema(), other.clazz);
                fieldSetFlags()[0] = true;
            }
            if (isValidValue(fields()[1], other.type)) {
                this.type = data().deepCopy(fields()[1].schema(), other.type);
                fieldSetFlags()[1] = true;
            }
            if (isValidValue(fields()[2], other.metadata)) {
                this.metadata = data().deepCopy(fields()[2].schema(), other.metadata);
                fieldSetFlags()[2] = true;
            }
            if (isValidValue(fields()[3], other.values)) {
                this.values = data().deepCopy(fields()[3].schema(), other.values);
                fieldSetFlags()[3] = true;
            }
            if (isValidValue(fields()[4], other.hasQualityIssues)) {
                this.hasQualityIssues = data().deepCopy(fields()[4].schema(), other.hasQualityIssues);
                fieldSetFlags()[4] = true;
            }
        }

        /** Gets the value of the 'clazz' field */
        public java.lang.String getClazz() {
            return clazz;
        }

        /** Sets the value of the 'clazz' field */
        public KafkaFlowRecord.Builder setClazz(java.lang.String value) {
            validate(fields()[0], value);
            this.clazz = value;
            fieldSetFlags()[0] = true;
            return this;
        }

        /** Checks whether the 'clazz' field has been set */
        public boolean hasClazz() {
            return fieldSetFlags()[0];
        }

        /** Clears the value of the 'clazz' field */
        public KafkaFlowRecord.Builder clearClazz() {
            clazz = null;
            fieldSetFlags()[0] = false;
            return this;
        }

        /** Gets the value of the 'type' field */
        public java.lang.String getType() {
            return type;
        }

        /** Sets the value of the 'type' field */
        public KafkaFlowRecord.Builder setType(java.lang.String value) {
            validate(fields()[1], value);
            this.type = value;
            fieldSetFlags()[1] = true;
            return this;
        }

        /** Checks whether the 'type' field has been set */
        public boolean hasType() {
            return fieldSetFlags()[1];
        }

        /** Clears the value of the 'type' field */
        public KafkaFlowRecord.Builder clearType() {
            type = null;
            fieldSetFlags()[1] = false;
            return this;
        }

        /** Gets the value of the 'metadata' field */
        public KafkaMetadataRecord getMetadata() {
            return metadata;
        }

        /** Sets the value of the 'metadata' field */
        public KafkaFlowRecord.Builder setMetadata(KafkaMetadataRecord value) {
            validate(fields()[2], value);
            this.metadata = value;
            fieldSetFlags()[2] = true;
            return this;
        }

        /** Checks whether the 'metadata' field has been set */
        public boolean hasMetadata() {
            return fieldSetFlags()[2];
        }

        /** Clears the value of the 'metadata' field */
        public KafkaFlowRecord.Builder clearMetadata() {
            metadata = null;
            fieldSetFlags()[2] = false;
            return this;
        }

        /** Gets the value of the 'values' field */
        public java.util.Map<java.lang.String,java.lang.String> getValues() {
            return values;
        }

        /** Sets the value of the 'values' field */
        public KafkaFlowRecord.Builder setValues(java.util.Map<java.lang.String,java.lang.String> value) {
            validate(fields()[3], value);
            this.values = value;
            fieldSetFlags()[3] = true;
            return this;
        }

        /** Checks whether the 'values' field has been set */
        public boolean hasValues() {
            return fieldSetFlags()[3];
        }

        /** Clears the value of the 'values' field */
        public KafkaFlowRecord.Builder clearValues() {
            values = null;
            fieldSetFlags()[3] = false;
            return this;
        }

        /** Gets the value of the 'hasQualityIssues' field */
        public java.lang.Boolean getHasQualityIssues() {
            return hasQualityIssues;
        }

        /** Sets the value of the 'hasQualityIssues' field */
        public KafkaFlowRecord.Builder setHasQualityIssues(boolean value) {
            validate(fields()[4], value);
            this.hasQualityIssues = value;
            fieldSetFlags()[4] = true;
            return this;
        }

        /** Checks whether the 'hasQualityIssues' field has been set */
        public boolean hasHasQualityIssues() {
            return fieldSetFlags()[4];
        }

        /** Clears the value of the 'hasQualityIssues' field */
        public KafkaFlowRecord.Builder clearHasQualityIssues() {
            fieldSetFlags()[4] = false;
            return this;
        }

        @Override
        public KafkaFlowRecord build() {
            try {
                KafkaFlowRecord record = new KafkaFlowRecord();
                record.clazz = fieldSetFlags()[0] ? this.clazz : (java.lang.String) defaultValue(fields()[0]);
                record.type = fieldSetFlags()[1] ? this.type : (java.lang.String) defaultValue(fields()[1]);
                record.metadata = fieldSetFlags()[2] ? this.metadata : (KafkaMetadataRecord) defaultValue(fields()[2]);
                record.values = fieldSetFlags()[3] ? this.values : (java.util.Map<java.lang.String,java.lang.String>) defaultValue(fields()[3]);
                record.hasQualityIssues = fieldSetFlags()[4] ? this.hasQualityIssues : (java.lang.Boolean) defaultValue(fields()[4]);
                return record;
            } catch (Exception e) {
                throw new org.apache.avro.AvroRuntimeException(e);
            }
        }
    }
}